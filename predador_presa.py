# -*- coding: utf-8 -*-
"""Predador-presa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rOvFkRZYdwnDBUuO51M_COYnGSGYVnKN
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

a = 1 #Tasa de crecimiento natural de conejos
b = 0.1 #exito de caza de lobo (decrecimiento de conejos)
c= 1.5  #Tasa de decrecimiento natural de lobos
e = 0.75 # exito caza lobos y crecimiento de los mismos

def dx_dt(x,t=0): #como se definen las funciones para depredadores y presas (lobos y conejos)
                  #dx/dt = ax - bxy (conejos)
                  #dy/dt = -cy + exy (lobos)
    return np.array([ a*x[0] - b*x[0]*x[1] + eps*x[0]*(1-x[0]) ,
                  -c*x[1] + e*b*x[0]*x[1] ]) 
    
def dx2_dt2(x,t=0): #para retornar la matriz jacobiana  
    return np.array([[a - b*x[1]+ eps*(1-2*x[0]), -b*x[0] ],
                  [e*b*x[1] , -c + e*b*x[0]] ])

eps=0
x_f0 = np.array([0. , 0.]) #punto critico 
x_f1 = np.array([ c/(e*b), a/b]) #punto critico

jac_f0 = dx2_dt2(x_f0) #el jacobiano evaluado en el primer punto critico  
jac_f1 = dx2_dt2(x_f1) #el jacobiano evaluado en el segundo punto critico 
lambda1 = np.linalg.eigvals(jac_f0) #halla los autovalores para el punto critico (0,0)
lambda2 = np.linalg.eigvals(jac_f1) #halla los autovalores para el segundo punto critico
#Para el segunto punto critico, los valores propios son imaginarios, por tanto da una solucion periodica,
# las trayectorias giran alrededor del punto critico. El periodo esta dado por:
T_f1 = 2*np.pi/abs(lambda2)

print("Primer punto critico es ",x_f0)
print("Segundo punto critico es ",x_f1)
print("-------------------------------")
print("La matriz Jacobiana para el Primer punto critico es \n",jac_f0)
print("La matriz Jacobiana para el segundo punto critico es \n",jac_f1)
print("-------------------------------")
print("el autovalor para el primer Jacobiano es ",lambda1)
print("el autovalor para el segundo Jacobiano es",lambda2)
print("-------------------------------")
t = np.linspace(0, 30,  1000)               # tiempo
x0 = np.array( [6,3] )                      # condiciones iniciales:6 conejos y 3 lobos
X = integrate.odeint(dx_dt, x0, t)          #soluciona el sistema de ecuaciones diferenciales de la funcion
                                            #depredador presa
conejos, lobos = X.transpose()    
f1 = plt.figure()
plt.plot(t, conejos, 'r-', label='Conejos')
plt.plot(t, lobos, 'b-', label='Lobos')
plt.grid()
plt.legend()
plt.xlabel('Tiempo')
plt.ylabel('Poblacion')
plt.show()

"""Se observa que en la figura que el sistema se mantiene estable. A medida que aumenta los conejos, hay mas alimentos para los lobos, y van a aumentar. Al disminuir la presa, llega a un máximo los predadores y como no hay para alimentarlos también van a disminuir hasta que se reproduzcan los conejos, manteniendo el ciclo."""

p  = np.linspace(0., 0.5, 6)   

f2 = plt.figure()
for i in (p):
    X0 = i * x_f1                               
    X = integrate.odeint( dx_dt, X0, t)         # son las condiciones iniciales de los animales
    plt.plot( X[:,0], X[:,1],lw=3.5*i,label='X0=(%.f, %.f)' % ( X0[0], X0[1]) ) 



ymax = plt.ylim(ymin=0)[1]                       
xmax = plt.xlim(xmin=0)[1]                       

x = np.linspace(0, xmax, 20)                      
y = np.linspace(0, ymax, 20)

X1 , Y1  = np.meshgrid(x, y)                      #para el flujo
DX1, DY1 = dx_dt([X1, Y1])  
                    


plt.streamplot(X1, Y1, DX1,DY1,color="k",density=(1,2),linewidth=0.5)
plt.title('Trayectoria y direccion del campo')
plt.xlabel('Numero de conejos')
plt.ylabel('Numero de lobos')
plt.xlim(-2,xmax)
plt.ylim(-2,ymax)


plt.legend()
plt.grid();

"""Demuestra que el sistema es periódico y cerrado con dichas condiciones iniciales."""